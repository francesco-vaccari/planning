PROBLEM1
Assumptions about problem1:
- a robot at a location has access to all workstations without needing to move further
- a robot can unload the content of a box if it is in the same location of the workstation, since the robot can access all workstations of that location
- unloading a box simply empties the box, leaving the content of the box at the given workstation and having still after the robot carrying an emtpy box
- boxes can be dropped by the robot at any location but not in workstations
- contents can only be dropped at workstations, and are found initially in the central_warehouse
- the central_warehouse is both a location and a workstation, has initially all boxes and all contents
- the robot can empty a box that is carrying, moving the content from the box to a workstation in the location it is in

I think it is better if i can implement the contents in a way that when a robot picks stuff up from the central_warehouse the stuff is not removed, and is like duplicated. This way the components are inifinite but i have to be careful because i still need them to disappear from ground if they are picked from any other workstation. To solve this problem, i might solve this problem by creating a special action that allows the robot to fill_up_at_cw and maybe also remove the central_warehouse_workstation so that the formulation is simpler by allowing the contents to be at a location when that location is only the central_warehouse.

Regarding problem1, I can also add a put_down_content_at_cw action that basically acts as bin for the contents that the robot has that are not needed anymore. This is not really needed since the goal do not require this action and it would never be actually performed. Still might be a good idea to add it.

Boxes instead are in a limited number and for each of them there is an instance initialized at central_warehouse. Boxes can only be dropped in locations, and not in workstations, which means that the action of unloading a box can be performed by a robot by simply being in the same locatino of the workstation and emptying the box. Robots can choose to also drop boxes at locations, but they never do because it is not optimal.

The way I modeled the contents of boxes, it is easy to add new kinds of componenents, like 'parts' in the problem defined. Also it is possible to add other robots that can pick up other boxes. Altough this produces a much longer plan searching time if we use astar to find the optimal plan. Observation about plans found, since we don't need boxes to be returned to the central_warehouse, the longest delivery is always performed last.


PROBLEM2
Assumptions about problem2:
- there are different kind of robots, the basic one which walks and can move obly between adjacent locations, and drones that can fly between arbitrary locations, maybe also some kind of jumping robot that can move by 2 locations at a time (walker, drone, jumper)
- carriers can be dropped at locations and not at workstations
- to load content to boxes the box has to be loaded in a carrier and the carrier must be attached, to load a box to a carrier the carrier must be attached and must have capacity available
- the carriers have a maximum capacity, up to 10 boxes
- a robot can have only one carrier attached at a time
- like before, contents are available with infinite restock at the central_warehouse

For the different kind of robots, I am planning to give the drone the highest cost for moving, the jumping robot should have less than double the cost of the walking robot so that it makes sense. I think this creates an interesting solution in cetrain environments, especially because the jumper cannot reach all the states, but only those with an even distance to the central_warehouse.

Because of the problem of the fluents/numeric-fluents not being implemented I had to change the way the max capacity for carriers is handled, the solution this way is far from clean and pretty meh but it works.

Interesting about the solution, only the drone makes actions, since it is the fastest way to move and since it spends the action to attach the carrier, any other robot starting from the central_warehouse would take the same amount of time to reach any new destination because it needs to attach the carrier before. Also, the drone attaches the carrier with capacity two in order to make only one trip to deliver the contents to the two workstations in location 2.


PROBLEM3
In general, the tasks allow only to specify the robot that does the action objects directly related to what we want the robot to do.

Tasks:
- move to location (move ?r - robot ?l - location)
    - if already at the location then done
    - if walker and 1 step away then move there
    - if walker and more than 1 step away the move to location and then call move again
    - if drone then fly to location
    - if jumper and 1 step away (2 locations) then move there
    - if jumper and more than 1 step away then move to location and then call move again

The carrier can be: already attached to robot, on the ground, attached to other robot.
- get a carrier (get_carrier ?r - robot ?car - carrier)
    To obtain a specific carrier the robot can:
    - if carrier already attached then done
    - if another carrier attached then detach it and call the task
    - if carrier detached then move to location of carrier and attach it
    - if carrier attached to another robot then detach it and call the task

The box can be: already loaded in carrier attached, on ground, loaded in a carrier (ground/attached managed by get carrier task).
- get a box (get_box ?r - robot ?b - box)
    To obtain a specific box the robot can:
    - if box already loaded in carrier attached then done
    - if box not loaded:
        - if carrier attached and non-zero capacity then move to location and load the box
        - if no carrier attached then get carrier with non-zero capacity and call the task
        - if carrier attached and zero capacity then:
            - get a new carrier with non-zero capacity and call the task
            - or drop a box and call the task
    - if box loaded in carrier not attached to robot then:
        - get the carrier
        - or drop the box from that carrier and call the task

Content is assumed to be found on ground only at central_warehouse, it can also be found in boxes (ground/loaded/attached managed by get box task).
- get content (?r - robot ?con - content). We assume to not find content anywhere expecet in the central_warehouse, this makes sense because any optimal solution will not have content lying on the ground outside of the central_warehouse. For the same reason, we do not allow robots to drop content anywhere because an optimal solution will never require this action.
    To obtain a specific content:
    - if content in box loaded to carrier attached then done
    - if empty box then move to central_warehouse and pick up the content
    - (if no empty boxes then) get an empty box and call the task
    - if no carrier attached then get carrier and call the task
    - if content in box then get the box

To implement optimal solutions we give the possibility to the robot to perform a indefinite number of get_content tasks before deliver the requested content.
- deliver content (?con - content ?w - workstation)
    - get content
    - move to location of workstation
    - put down content at workstation


The solution that it finds is not optimal when considering the number of actions performed. In fact, if we force the robot to move only in a direction, it will find a solution with less actions but that uses more methods.



PROBLEM4
Incredible discovery, the optic found in planutils does support numeric fluents but it does not support negative preconditions. I don't even know how I found out. But anyway, I remade the problem 2 with the numeric fluents and now I will try to go on with problem 4 using the fluents, hoping that it works. I had to modify slightly some actions and some checks are gone so optimal solutions will take longer to be found. Also I needed to add some more predicates to allow preconditions to not have to check for negative predicates.

Since with optic it works, I will continue with the fluents for Problem4, hoping that it will work also with Problem5.

Actions done by different robots can obviously overlap, while actions done by a robot can overlap only if they are the same actions, so for example a robot can load multiple boxes at the same time, or picking up multiple things at cw, or deliver multiple contents. Also, moving and doing anything else are mutexes, attaching a carrier is also mutex to anything else, but loading a box can be done at the same time as loading other boxes or picking up contents as long as the boxes in which the content will be is not the box is being loaded. This is not really useful in solutions since if a robot needs a number of boxes it will pick all them up at the same time.

I could implement, as specified in the pdf, that a robot can load only a box at a time. I would simply need a mutex to lock when starting the laod_box action and unlock it when the action is done. The same mutex is also used for unloading boxes. This also means that a robot cannot load/unload boxes at the same time.



PROBLEM5
I think I will have to do this on a machine with ubuntu because the docker does not build correctly and I am tired of things not working. I think I got it working on docker.

From what I understood I need to modify the files in src for the actions implemented in c++, and then I need to modify the python file in the launch folder.

The default folder contains launch, pddl and src folders. The launch folder containes "command" and the launch py file, the pddl contains the pddl domain file, the src folder contains a ccp file for each of the actions. Then there is the CMakeLists.txt file in the root, the package.xml file also in the root.

I think I just need to rename the folder to src, and move it into a new directory, then run in the directory the commands:
    rosdep install --from-paths src --ignore-src -r -y
    colcon build --symlink-install
    source install/setup.bash
Then to run execute in another terminal
    ros2 launch [package_name] [package_name]_launch.py
And then run the plansys2 terminal
    ros2 run plansys2_terminal plansys2_terminal

For some reason I need to rerun the source setup.bash command otherwise it does not find the package. Also, to launch the action server I need to be in the same directory of where I run the build commands.


I am getting an error when launching the problem, probably it does not support numeric-fluents. I changed back to the domain definitio without the fluents, with capacities up to 10.
Also it looks like that when loading the domain file it does not sets the instances of the constant istances like central_warehouse and the numbers. So I will add them in the problem instance commands.

These are the commands with the name of the package being "problem5":
    ros2 launch problem5 problem5_launch.py
    ros2 run plansys2_terminal plansys2_terminal
Then run in the ros terminal:
    source launch/commands
    get plan
    run

The duration of actions have been scaled down by a factor of, keeping the proportions between action durations the same. Also, by putting the progress update every .1 it should make actions last exactly the original amount as defined in the pddl domain file. I should check this maybe.

I checked and the thing about action durations is true. They last the same amount of seconds as defined in the domain file.